/*
 XYVector(T*,intn) // Aya //////////////Done
 XYVector(constXYVector&) //Hadeer //////Done
 XYVector &operator=(const Vector&&); //Hadeer ///////Done
 T pop_back() //Aya //////////////Done
 void erase(iterator) //Hadeer /////Done
 _________________________
 1[0] 2[1] 3[2] 4[3]
 we want to erase 3 in index 2
 decrease 4's position to 1
 and the size of the vector will be decreased by one
 ___________________________________________
 void erase(iterator1,iterator2) //Aya //////////Done
 void clear() //Hadeer
 operations on iterators(*,++,+,begin,end) //Aya
 void insert(iterator,T) //Hadeer 
 booloperator==(constXYVector<T>&) //Hadeer ////////Done
 booloperator<(constXYVector<T>&) //Hadeer ////////////Done
 int capacity()const//Returnsizeofcurrentallocatedarray //Hadeer //////////Done
 int resize() //Relocatetobiggerspace //Hadeer /////////////Done
 bool empty() //Hadeer  ////////Done
 friend ostream&operator<<(ostream&out,XYvector<T>) //Hadeer




 */
#include <bits/stdc++.h>

using namespace std;

template <class T>
class HAVector{
private:
    int size, capacity;
    T* data;
public:
    HAVector(int cap = 2){ //constructor(int)
        capacity = cap;
        size = 0;
        data = new T[capacity];
    }
    ~HAVector(){//destructor()
        delete[] data;
    }
    T& operator[](int indx){ // Access modi
        if(indx > size-1){
            cout << "An error has occured, index out of range." << endl;
            exit(-1);
        }
        return data[indx];
    }
    void push_back(T item){
        if(size < capacity){
            data[size++] = item;
        }
        else{
            cout << "Resizing to " << capacity*2 << endl;
            T* newdata = new T[capacity*2];
            capacity *= 2;

            for(int i = 0; i < size; i++){
                newdata[i] = data[i];
            }
            delete[] data;
            data = newdata;
            newdata = nullptr;
            data[size++] = item;
        }
    }
    int getSize(){
        return size;
    }
    T& operator=(const T& other){   //copy Ass
        if(this != &other){
            delete[] data;
            size = other.size;
            capacity = other.capacity;
            data = new T[capacity];
            for(int i = 0; i < other.size; i++){
                data[i] = other.data[i];
            }
        }
        else{
            cout << "Cannot delete self" << endl;
        }
    }
    HAVector(T* arr,int n)
    {
            size = n;
            capacity = n;
            data = new T[capacity];
            for(int i = 0; i < n; i++){
                data[i] = arr[i];
            }

    }

   T pop_back(){
        return data[--size];
    }
   void erase (auto iterator1,auto iterator2)
    {
        if(iterator2 <= size && iterator1 <= size && iterator1<=iterator2){
            auto P = new T[size];
            int j=0;
            for(int i = 0; i < iterator1-1; i++){
                P[j] = data[i];
                j++;
            }
            for(int i = iterator2; i < size; i++){
                P[j] = data[i];
                j++;
            }
            delete [] data;
            data = P;
            size -= (iterator2-iterator1+1);
        }
        else{
            cout<<"This range can't be erased.\n";
        }

    }
    void erase (auto iterator)
    {
        //0[aya] 1[ali] 2[hassan]
        // 2
        if(iterator <= size ){
            auto P = new T[size];
            int j=0;
            for(int i = 0; i < iterator-1; i++){
                P[j] = data[i];
                j++;
            }
            for(int i = iterator; i < size; i++){
                P[j] = data[i];
                j++;
            }
            delete [] data;
            data = P;
            size --;
        }
        else{
            cout<<"This range can't be erased.\n";
        }

    }
    //Hadeer
       HAVector(const T& other){         // copy constructor.
        size = other.size;
        capacity = other.capacity;
        data = new T[capacity];
        for(int i = 0; i < other.size; i++){
            data[i] = other.data[i];
        }}
        
        
        T& operator=(const T&& other){           // move ass
        if(this != &other){
            delete[] data;
            size = other.size;
            capacity = other.capacity;
            data = new T[capacity];
            for(int i = 0; i < other.size; i++){
                data[i] = other.data[i];
            }
        }
        else{
            cout << "Cannot delete self" << endl;
        }
    }
    
     bool operator==(const  HAVector<T>& vec2){
        int count = 0;
        if(size == vec2.size){
            for (int i = 0; i < vec2.size ; ++i) {
                if(data[i] == vec2.data[i]){
                    count++;
                }
            }
            if(count == size){
                return true;
            }
    }}
    
    bool operator<(const HAVector<T>& vec){
        if (size < vec.size){
            return true;
        }
        else if (size == vec.size){
            for (int i = 0; i < vec.size ; ++i) {
                if(data[i] < vec.data[i]){
                    return true;
        }
                break;

            }
        }
    }
    
    int resize(){
        int n;
       // cout <<""
        cin >> n;
        cout << "Resizing to " << capacity*n << endl;

        capacity *= n;
    }
    int getcapacity(){
        return capacity;
    }
    bool empty(){
        if(getSize() == 0){
            return true;
        }


    }

};

int main(){
    HAVector <string> vec(1);
    vec.push_back((string) "Hello");
    vec.push_back((string) "Neehaw");
    vec.push_back((string) "Bonjour");
    vec.push_back((string) "Guten Tag");
    vec.push_back((string) "Salam Alykum");
    vec.push_back((string) "Hola");
    vec[0] = "Hellooooo";

    for(int i = 0; i < vec.getSize(); i++){
        cout << vec[i] << endl;
    }
    cout << endl << endl;
    HAVector <string> vec2;
    vec2 = vec;
    vec2[0] = "Salam Alykum231";

    for(int i = 0; i < vec2.getSize(); i++){
        cout << vec2[i] << endl;
    }
    if((vec == vec2)){
    cout <<"equal"<< endl;
    }
    if((vec < vec2)){cout << "first vector is smaller." << endl;}
  string arr[5];
    arr[0]="Aya";arr[1]="Ali";arr[2]="Hassan";arr[3]="Ali";arr[4]="....";
    HAVector<string> vec3(arr,5);
    for(int i = 0; i < vec3.getSize(); i++){
        cout << vec3[i] << endl;
    }
    cout<<endl;
    vec3.pop_back();//Aya Ali Hassan Ali

    for(int i = 0; i < vec3.getSize(); i++){
        cout << vec3[i] << endl;
    }
    cout<<endl;
    vec3.erase(1,2); //Hassan Ali

    for(int i = 0; i < vec3.getSize(); i++){
        cout << vec3[i] << endl;
    }
    cout<<endl;
    cout<<vec3.getSize()<<endl;

    vec3.erase(1); //Ali
    for(int i = 0; i < vec3.getSize(); i++){
        cout << vec3[i] << endl;
    }
    cout << vec3.getSize();
    cout << vec3.getcapacity();
    if(vec3.empty()){ cout << "vector is empty" << endl;}




}
